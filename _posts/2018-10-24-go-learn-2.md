---
layout: post
title:  go学习笔记2
categories: go
tags: go golang interface
thread: golang
---
## 接口值
有两部分组成
* 具体的类型，也称接口的动态类型
* 那个类型的值，也称接口的动态值

变量总是被一个定义明确的值初始化，接口类型也不例外。

**对于一个接口的零值就是它的类型和值的部分都是`nil`**

```golang
package main

import (
    "io"
    "fmt"
    "os"
    "bytes"
)

func main() {
    var w io.Writer       // interface 不管 `w` 保存了什么值，它的类型都是 `io.Writer`
    fmt.Printf("%T\n", w) // print nil

    w = os.Stdout
    fmt.Printf("%T\n", w)      // print *os.File
    w.Write([]byte("hello\n")) // print hello

    w = new(bytes.Buffer)
    fmt.Printf("%T\n", w) // print *bytes.Buffer

    b := new(bytes.Buffer) // struct
    fmt.Printf("%T\n", b)  // print *bytes.Buffer
    b.Write([]byte("world"))
    fmt.Println(b.String()) // print world
}

```

接口值可以使用＝＝和！＝来进行比较。两个接口值相等仅当它们都是nil值或者它们的动态类型相同并且动态值也根据这个动态类型的＝＝操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。

然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic.

## interface接口
```golang
package main

import (
    "fmt"
    "strings"
)

type Interface interface {
    Len() int
    Less(i, j int) bool // i小于j的比较结果
    Swap(i, j int)
}

type StringSlice []string

func (p StringSlice) Len() int {
    return len(p)
}

func (p StringSlice) Less(i, j int) bool {
    return p[i] < p[j]
}

func (p StringSlice) Swap(i, j int) {
    p[i], p[j] = p[j], p[i]
}

func main() {
    var names = StringSlice{"Python", "Go", "Java", "C"}

    fmt.Println(strings.Join(names, " "))
    for i := 0; i < names.Len()-1; i++ {
        if names.Less(i, i+1) {
            names.Swap(i, i+1)
        }
    }
    for _, item := range names[:names.Len()-1] {
        fmt.Println(item)
    }
    fmt.Println(strings.Join(names, " "))
}

```

实现排序的基础三个方法`Len`, `Less`, `Swap`


## 类型断言
类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。

### 第一种
如果断言的类型T是一个具体类型，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出panic.

### 第二种
如果断言的类型T是一个接口类型，然后类型断言检查是否x的动态类型满足T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同类型和值部分的接口值，但是结果有类型T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保护了接口值内部的动态类型和值的部分。

```golang
package main

import (
    "fmt"
    "io"
    "os"
    "bytes"
)

func main() {
    var w io.Writer

    w = os.Stdout

    f := w.(*os.File)
    fmt.Println(f)
    
    c, ok := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer
    fmt.Println(c)
    fmt.Println(ok)

    var v interface{}
    v = 1234
    switch v.(type) {
    case string:
        fmt.Printf("The string is %s", v.(string))
    case int, uint, int8:
        fmt.Printf("The integer is %d", v)
    default:
        fmt.Printf("Unknown value: type=%T", v)
    }
}
```

## 接口设计
* 1.接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要
* 2.当一个接口只被一个单一的具体类型时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在相同的包中，这种情况下，一个接口是解耦这两个包的一个好方式。

在Go语言中只有两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法的更小的接口。当新的类型出现时，小的接口更容易满足。

**接口设计一个好的标准就是: ask only for what you need（只考虑你需要的东西）**

## Goroutines
主函数返回时，所有的goroutine都会被直接打断，程序退出。
除了从主函数退出或者直接终止程序外，没有其它编程方法能够让一个goroutine来打断另个一个的执行。

## Channels
一个channel有发送和接收两个主要操作，都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。

发送和接收操作都是使用`<-`运算符。在发送语句中，`<-`分割channel和要发送的值。在接收语句中,`<-`写在channel对象之前。一个不使用接收结果的接收操作也是合法的。

```golang
ch <- x // 发送一个值
y := <- ch // 接收一个值
<-ch //将要接收的值丢弃
```







