---
layout: post
title: 理解 >/dev/null 2>&1 含义
categories: shell
tags: linux shell dev null stdout stderr
thread: shell
---
## 前言
在之前shell脚本中间经常看到`>/dev/null 2>&1`，一直只是理解为忽略shell执行错误，并把输出抛到黑洞中。基于想实现把执行信息追加到指定文件中且不输出到终端，一直出了些小问题，打算详细理解下`>/dev/null 2>&1`语法含义。

## shell重定向
就像我们平时写的程序一样，一段程序会处理外部的输入，然后将运算结果输出到指定的位置。在交互式的程序中，输入来自用户的键盘和鼠标，结果输出到用户的屏幕，甚至播放设备中。而对于某些后台运行的程序，输入可能来自于外部的一些文件，运算的结果通常又写到其他的文件中。而且程序在运行的过程中，会有一些关键性的信息，比如异常堆栈，外部接口调用情况等，这些都会统统写到日志文件里。

shell脚本也一样，但是我们一般在使用shell命令的时候，更多地还是通过键盘输入，然后在屏幕上查看命令的执行结果。如果某些情况下，我们需要将shell命令的执行结果存储到文件中，那么我们就需要使用输入输出的重定向功能。


## 文件描述符
当执行shell命令时，会默认打开3个文件，每个文件有对应的文件描述符来方便我们使用：

|类型|文件描述符|默认情况|对应文件句柄位置|
|:---|:---|:---|:---|
|标准输入(standard input)|0|从键盘获得输入|/proc/self/fd/0|
|标准输出(standard output)|1|输出到屏幕(即控制台)|/proc/self/fd/1|
|错误输出(error output)|2|输出到屏幕(即控制台)|/proc/self/fd/2|

所以我们平时在执行shell命令中，都默认是从键盘获得输入，并且将结果输出到控制台上。但是我们可以通过更改文件描述符默认的指向，从而实现输入输出的重定向。比如我们将1指向文件，那么标准的输出就会输出到文件中。

## 输出重定向

输出重定向的使用方式很简单，基本的一些命令如下：

|命令|介绍|
|:---|:---|
|command >filename|把标准输出重定向到新文件中|
|command 1>filename|把标准输出重定向到新文件中|
|command >>filename|把标准输出追加到文件中|
|command 1>>filename|把标准输出追加到文件中|
|command 2>filename|把标准错误重定向到新文件中|
|command 2>>filename|把标准错误追加到新文件中|

我们使用>或者>>对输出进行重定向。符号的左边表示文件描述符，如果没有的话表示1，也就是标准输出，符号的右边可以是一个文件，也可以是一个输出设备。当使用>时，会判断右边的文件存不存在，如果存在的话就先删除，然后创建一个新的文件，不存在的话则直接创建。但是当使用>>进行追加时，则不会删除原来已经存在的文件。

## 输入重定向

|命令|介绍|
|:---|:---|
|command <filename|以filename文件作为标准输入|
|command 0<filename|以filename文件作为标准输入|
|command <<delimiter|从标准输入中读入，直到遇到delimiter分隔符|

我们使用`<` 对输入做重定向，如果符号左边没有写值，那么默认就是0。

## 重定向绑定
* \>/dev/null

这条命令的作用是将标准输出`1`重定向到`/dev/null`中。 /dev/null代表linux的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称`黑洞`。那么执行了>/dev/null之后，标准输出就会不再存在，没有任何地方能够找到输出的内容。

* 2>&1

这条命令用到了重定向绑定，采用`&`可以将两个输出绑定在一起。这条命令的作用是**将错误输出和标准输出同用一个文件描述符，即将错误输出将会和标准输出输出到同一个地方。**

linux在执行shell命令之前，就会确定好所有的输入输出位置，并且`从左到右`依次执行重定向的命令，所以`>/dev/null 2>&1`的作用就是让标准输出重定向到/dev/null中（丢弃标准输出），然后错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了/dev/null中，错误输出同样也被丢弃了。执行了这条命令之后，该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。

* \>/dev/null 2>&1 VS 2>&1 >/dev/null

linux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令。

`2>&1`，将错误输出绑定到标准输出上。由于此时的标准输出是默认值，也就是输出到屏幕，所以错误输出会输出到屏幕。

`>/dev/null`，将标准输出`1`重定向到/dev/null中。 

|命令|标准输出|错误输出|
|:---|:---|:---|
|>/dev/null 2>&1|丢弃|丢弃|
|2>&1 >/dev/null|丢弃|屏幕|

* \>/dev/null 2>&1 VS >/dev/null 2>/dev/null

采用这种写法，标准输出和错误输出会抢占往out文件的管道，所以可能会导致输出内容的时候出现缺失、覆盖、乱码等情况。**采用这种写法，最后的情况是无法预估的。**

而且，**由于文件被打开了两次，两个文件描述符会抢占性的往文件中输出内容，所以整体IO效率不如>/dev/null 2>&1来得高。**
