---
layout: post
title:  MySQL锁机制
tags: lock mysql oltp olap
thread: mysql
---

## 概述
数据库中的锁定机制就是为了保证数据的一致性，而使各种共享资源在被并发访问变得有序索所设计的一种规则。

MySQL数据库有多种数据存储引擎，每种数据引擎针对应用场景特点都不一样，都是针对特定场景而优化设计的，所以各存储引擎的锁定机制也有较大区别。

MySQL各存储引擎使用了三种类型(级别)的锁定机制：表级锁定、行级锁定、页级锁定。

在数据库实现资源锁定的过程中，随着锁定粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是原来越多的，实现算法也会越来越复杂。不过随着锁定资源粒度的减小，应用程序的访问请求遇到的锁等待的可能性会随之降低，系统的整体并发度也会随之提升。

## 表级锁定
最大粒度的锁定机制，特点是实现逻辑简单，带来的系统负面影响小。

### 优点
* 1.锁的获取和释放都很快。
* 2.由于表级锁一次会将整个表锁定，可以避免死锁问题。

### 缺点
* 1.锁粒度大，导致锁定资源竞争激烈，并发度低

### 主要引擎
MyISAM、MEMORY、CSV等一些非实物性存储引擎

## 行级锁定
最小粒度的锁定机制，发生锁定资源的争用概率小，在并发度上会有所提升。

### 优点
* 1.并发能力强

### 缺点
* 1.由于粒度小，导致锁资源释放获取消耗资源会相对较多
* 2.容易发生死锁

### 主要引擎
InnoDB存储引擎

## 页级锁定
属于比较独特的锁定级别，在其他数据库中比较不常见，特点就是锁定粒度介于表级锁定和行级锁定之间。所以获取锁资源开销及能提供的并发能力也是介于两者之间。也有可能发生死锁。

### 主要引擎
BerkeleyDB存储引擎

## 对比
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；

行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；

页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。


## 总结
从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理[OLTP](/oltp-olap)系统。

## 参考
[MySQL锁详解](https://www.cnblogs.com/luyucheng/p/6297752.html)