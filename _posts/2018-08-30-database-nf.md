---
layout: post
title: 第一范式、第二范式、第三范式
categories: mysql
tags: mysql nf
thread: mysql
---
## 范式
符合某一种级别关系模式的集合，表示一个关系内部各属性直接的联系的合理化程度。口语化为**一张数据表的表结构所符合的某种设计标准的级别**

### 范式分类

由低到高排列

* 1NF
* 2NF
* 3N
* BCNF
* 4NF
* 5NF

一般在设计关系型数据库是，考虑到`BCNF`即可。**符合高一级范式的设计，必定符合低一级方式。**

### 目标
* 1.减少数据冗余(这是最主要的好处)
* 2.消除异常(插入异常、更新异常、删除异常)
* 3.让数据组织更加和谐

## 第一范式
数据库表的每一列都是不可分割的数据数据项，同一列中不能有多个值，实体的某个属性不能有多个值或者不能有重复的属性。**即每个属性都不可再分，每条记录都能利用唯一的主键进行识别。**

**在任何一个关系数据库中，第一范式是关系模型的基本要求，不满足第一范式的数据库就不是关系数据库。**

## 第二范式
在第一范式的基础上，消除非主属性对于码的部分函数依赖。只有一个主键的表如果符合第一范式，那一定是第二范式。**表中的属性必须完全依赖于全部主键，而不是部分主键.简而言之，第二范式就是属性完全依赖于主键。**

* 函数依赖

若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。

* 完全函数依赖

在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ' → Y 不成立，那么我们称 Y 对于 X 完全函数依赖.

* 部分函数依赖

假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X.

* 传递函数依赖

假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （Y 不包含于 X，且 X 不函数依赖于 Y），那么我们就称 Z 传递函数依赖于 X。

* 码

设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K，那么我们称 K 为候选码，简称为码。

* 主属性

包含在任何一个码中的属性称为主属性

### 判断方法

* 第一步：找出数据表中所有的码。
* 第二步：根据第一步所得到的码，找出所有的主属性。
* 第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。
* 第四步：查看是否存在非主属性对码的部分函数依赖。

## 第三范式
满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。**简而言之，第三范式就是属性不依赖于其它非主属性。 
**

## BCNF
在满足第三范式的基础上，且不允许主键的一部分被另一部分或其它部分决定。

### 判断方法
* 1.满足第三范式。
* 2.所有非主属性对每一个码都是完全函数依赖。
* 3.所有的主属性对每一个不包含它的码，也是完全函数依赖。
* 4.没有任何属性完全函数依赖于飞码的任何一组属性。

## 参考
* [解释一下关系数据库的第一第二第三范式?](https://www.zhihu.com/question/24696366)

